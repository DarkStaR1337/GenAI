import pandas as pd
import json
import ast
import traceback
from datetime import datetime, timedelta
from typing import Dict, Any, List, Union
from langchain_aws import ChatBedrockConverse
from langchain_core.messages import HumanMessage, SystemMessage

def ensure_json_serializable(obj):
    """Ensure object is JSON serializable"""
    if isinstance(obj, (str, int, float, bool, type(None))):
        return obj
    elif isinstance(obj, (list, tuple)):
        return [ensure_json_serializable(item) for item in obj]
    elif isinstance(obj, dict):
        return {str(k): ensure_json_serializable(v) for k, v in obj.items()}
    elif isinstance(obj, pd.DataFrame):
        return obj.to_dict(orient='records')
    elif isinstance(obj, pd.Series):
        return obj.tolist()
    elif hasattr(obj, 'item'):  # numpy types
        return obj.item()
    elif hasattr(obj, 'tolist'):  # numpy arrays
        return obj.tolist()
    else:
        return str(obj)

# Initialize Bedrock client
def get_bedrock_client():
    """
    Initialize the ChatBedrockConverse client
    Make sure to configure AWS credentials via:
    - AWS CLI: aws configure
    - Environment variables: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_DEFAULT_REGION
    - IAM roles (recommended for production)
    """
    return ChatBedrockConverse(
        model_id="anthropic.claude-3-sonnet-20240229-v1:0",  # or use claude-3-haiku for faster responses
        region_name="us-east-1",  # Change to your preferred region
        model_kwargs={
            "max_tokens": 1000,
            "temperature": 0.15
        }
    )

def date_now():
    """Get current date plus 5 hours 30 minutes formatted as %d-%b-%Y"""
    date = datetime.now()
    ist_now = date + timedelta(hours=5, minutes=30)
    formatted_date = ist_now.strftime("%d-%b-%Y")
    return formatted_date

def bedrock_call(prompt: str, system_prompt: str = "You are a helpful assistant.") -> str:
    """
    Call AWS Bedrock with the given prompt using LangChain ChatBedrockConverse
    """
    try:
        client = get_bedrock_client()
        
        messages = [
            SystemMessage(content=system_prompt),
            HumanMessage(content=prompt)
        ]
        
        response = client.invoke(messages)
        return response.content.strip()
        
    except Exception as e:
        return "Sorry, I can only answer offense related questions."

def chat_response_format(query: str, result: Any) -> str:
    """
    Format chat response - same logic as original
    """
    prompt = f"""
You are given a user query: {query}

- The user input received may be a single record or a single word, as long as it answers the user query do not modify it.
- The user input you receive comes from a data frame. Carefully restructure the result to answer the user's query.
- Do not change dates if present.
- Do not add, generate, or categorize any additional information.
- Restructure the provided result to directly answer the user query in clear, natural language.
- Do not modify or remove any of the given information; only restructure the user input.
- Format the response in a user-friendly style, such as bullet points or numbered lists.
- If there are 30 records in the user input and the total count, present the records as a numbered list and specify the total number of records.
- If any error message appears in the user input, respond only with: "Sorry, try again."
- If the user input is empty, respond only with: "There is no data for this query."
- Ensure your answers are always consistent in style and approach.
"""
    
    if isinstance(result, pd.DataFrame):
        res = result.to_json(orient='records')
    elif isinstance(result, pd.Series):
        res = '\n'.join(result.astype(str))
    elif not isinstance(result, str):
        res = str(result)
    else:
        res = result
    
    return bedrock_call(res, system_prompt=prompt)

def classify_question(question: str) -> str:
    """
    Classify question as 'chat' or 'graph' - same logic as original
    """
    graph_keywords = ["chart", "plot", "graph", "chart", "draw", "visualize", "visualise"]
    for keyword in graph_keywords:
        if keyword in question.lower():
            return "graph"
    return "chat"

def determine_chart_type_bedrock(question: str) -> str:
    """
    Determine chart type using Bedrock instead of GPT-4
    """
    chart_system_prompt = """
You are a data visualization assistant.
Given only the user's question, respond with ONLY ONE WORD:
"bar", "pie", or "trendline", whichever is most appropriate for visualizing data relevant to the question.
If the user asks about counts or comparison by category, use "bar".
If the user asks for proportions or distribution, use "pie".
Reply with only the chart type. Do not explain.
"""
    
    prompt = f"Question: {question}\nChart type:"
    chart_type = bedrock_call(prompt, system_prompt=chart_system_prompt)
    
    # Normalize and validate output
    chart_type = chart_type.lower().strip()
    if chart_type not in ["bar", "pie", "trendline"]:
        chart_type = "bar"
    
    return chart_type

def strip_imports(code: str) -> str:
    """
    Remove lines starting with 'import' or 'from ... import ...' from the code.
    """
    lines = code.split('\n')
    filtered = [line for line in lines if not line.strip().startswith('import') and not line.strip().startswith('from ')]
    return '\n'.join(filtered)

def extract_entities_and_code(question: str, df_columns: List[str], question_type: str) -> str:
    """
    Generate pandas code using Bedrock - same comprehensive prompt as original
    """
    schema = "\n".join(f"- {col}" for col in df_columns)
    
    prompt = f"""
Question type: {question_type}
DataFrame schema:
{schema}

Instruction:
Generate safe, robust pandas code to answer this question:

Question: {question}

Requirements:
- Use the DataFrame named 'df'
- In the generated python code, always assign the final output to a variable named result and ensure the last line is: result
- Understand when user is asking 2 questions together and answer them separately.
- Check data type before making python code and make the correct codes.
- For count only give the count. List should only be returned if asked for it.
- When filtering or aggregating by date or time for any offense (for trends, date range, etc), ALWAYS use the "start_time" column, unless the question specifically asks for a different date column.
- If filtering by date, assume date columns are in '%d-%b-%Y' format; use pd.to_datetime as needed
- If asked for only a particular column, Then result should be the unique values for the column only.
- For columns "source_address_ids", "destination_methods", "categories", "local_destination_address_ids" are lists. Therefore, Create correct python code accordingly.
- In case there are more than 30 records in the result dataframe, return top 30 and total length of the result dataframe.
- For columns "rules", "log_sources": Each record is a list of dictionaries, .explode() creates pandas Series.Therefore, Create correct python code accordingly.use list comprehension to get unique values as a string
- For column "rules" and "log_sources": 
- Each record is a list of dictionaries.
- To get unique dictionaries, after '.explode()', filter with 'isinstance(x, dict)'.
- Since '.unique()' doesn't work on dicts, use 'import json' and apply 'json.dumps(d, sort_keys=True)' to each dict to get unique values (as strings), then use 'json.loads()' back to dict if needed.
- Expectation is to have the consistent fields: description, categories, created_time, assigned_to, status if offense is OPEN/CLOSED' then Closure_time and the Closure_code while calculating average or mean time, specify and return the unit.
- For Details/Summary for a particular month, week, or custom date range, provide a top-level summary of the offense trend for that period, which should include: Total offenses, Open offenses, Closed offenses, Breakdown of offenses by severity, Breakdown of offenses by closure code.
- For week-based queries within a month (e.g., 'first week of June'), define weeks as follows: 1st week: 1st to 7th, 2nd week: 8th to 14th, 3rd week: 15th to 21st, 4th week: 22nd to 28th, 5th week: 29th to end of the month (inclusive).
- Understand timeframe queries (yesterday/last day, today, last month, last week, last 24 hours, last to x days, name of the month, etc.) precisely.
- If the query is irrelevant to the DataFrame, respond: "Sorry, I can only help with queries related to offenses."
- If the query asks for the 'How' or 'procedure', respond: "Sorry, cannot help you with this."
- never display time in epoch. Always in IST.
- Current date is: {date_now()}
- Code (do not explain):

severity: ['Medium Severity', 'High Severity', 'Low Severity','Critical Severity']
closing_reason_id: ['Benign True Positive','True Positive','False Positive','Policy Violation','Non-issue','No Response Received']
If the answer is a table or summary, assign it to a variable named result.
if question type is graph, output 'result' as a list of dicts: [{{"category": string, "value": int}}]. The keys should be constant "category" and "value". Categories when asked for top offenses consider the 'description' column.
Never use print() or display().
Be consistent with answers even if the question type or question formation or the type of graph in the question changes. Focus on the information required.
Do NOT use dangerous methods or anything but pandas and Python. Give the proper python code.
Do NOT execute the code. Just output the code string.
Keep the code minimal and correct and simple and straightforward. Be consistent with the code created. Even if same question is asked in a different way.
If the keyword 'last' is used (like 'last 7 days', 'last week'), EXCLUDE today from the range; select data from (today - N days) up to (but not including) today.
Last 5 days means last 5 calendar days immediately preceding today, excluding today.
Last month is the last month from current month. Last 30 days is the last 30 days from today but excluding today.
Last week is the previous Monday to Sunday (excluding this week's Monday onward).
Last 7 days is the last 7 days before today but excluding today.
'Closed offenses' are the same as 'offenses with status closed'.
For Details/Summary for a particular month provide a top level summary of the offense trend for that month which should include: Total offenses, Open offenses, Closed offenses by severity, Breakdown of offenses by closure code.
# For Details/Summary for a particular month, week, or custom date range, provide a top-level summary of the offense trend for that period,
# which should include: Total offenses, Open offenses, Closed offenses, Breakdown of offenses by severity, Breakdown of offenses by closure code.
"""
    
    code = bedrock_call(prompt)
    code = code.replace("```python", "").replace("```", "")
    return code

def safe_run_pandas_code(code: str, df: pd.DataFrame) -> Any:
    """
    Run the generated pandas code in a controlled environment - same as original
    """
    code = strip_imports(code)
    print(code)
    safe_locals = {
        "df": df.copy(), 
        "pd": pd, 
        "datetime": datetime, 
        "timedelta": timedelta, 
        "json": json
    }
    
    try:
        exec(code, safe_locals)
        return safe_locals["result"]
    except Exception as e:
        traceback.print_exc()
        return f"Error running generated code: {e}"

class ChatAgent:
    def __init__(self, df: pd.DataFrame):
        self.df = df.copy()
    
    def handle(self, question: str) -> str:
        df_cols = self.df.columns.tolist()
        code = extract_entities_and_code(question, df_cols, question_type="chat")
        result = safe_run_pandas_code(code, self.df)
        result2 = chat_response_format(question, result)
        
        # Format answer for display
        if isinstance(result2, pd.DataFrame):
            return result2.head(100).to_string(index=False)
        if isinstance(result2, pd.Series):
            return result2.to_string()
        if isinstance(result2, (str, int, float, list, dict)):
            return str(result2)
        return "No results or unrecognized output."

class GraphAgent:
    def __init__(self, df: pd.DataFrame):
        self.df = df.copy()
    
    def handle(self, question: str) -> tuple:
        df_cols = self.df.columns.tolist()
        chart_type = determine_chart_type_bedrock(question)
        
        for word in ['bar', 'graph', 'pie', 'chart']:
            question = question.lower().replace(word, '')
        
        code = extract_entities_and_code(question, df_cols, question_type="graph")
        result = safe_run_pandas_code(code, self.df)
        
        # Always output as a JSON array of objects [{"category": ..., "value": ...}]
        if isinstance(result, str):
            try:
                result_obj = ast.literal_eval(result)
            except Exception:
                result_obj = result
        else:
            result_obj = result
        
        # Convert to serializable format and ensure it's clean
        if isinstance(result_obj, (list, dict)):
            graph_data = ensure_json_serializable(result_obj)
        elif isinstance(result_obj, pd.DataFrame):
            graph_data = ensure_json_serializable(result_obj.to_dict(orient='records'))
        else:
            graph_data = []
        
        return graph_data, chart_type

class CoordinatorAgent:
    def __init__(self, df: pd.DataFrame):
        self.chat_agent = ChatAgent(df)
        self.graph_agent = GraphAgent(df)
    
    def handle_query(self, question: str) -> Dict[str, Any]:
        qtype = classify_question(question)
        
        if "graph" in qtype:
            graph_data, chart_type = self.graph_agent.handle(question)
            return {
                "text": "",
                "graph_data": ensure_json_serializable(graph_data),
                "type": str(chart_type)
            }
        elif "chat" in qtype:
            chat_text = self.chat_agent.handle(question)
            return {
                "text": str(chat_text),
                "graph_data": None,
                "type": "text"
            }
        else:
            return {
                "text": "Sorry, could not determine your question.",
                "graph_data": None,
                "type": "text"
            }

def get_offenses_response_new(query: str) -> Dict[str, Any]:
    """
    Main function to get response - replace get_jubilent_offense() with your data loading function
    """
    df = get_jubilent_offense()  # Replace this with your actual data loading function
    coordinator = CoordinatorAgent(df)
    response = coordinator.handle_query(query)
    
    # Ensure everything is JSON serializable
    response = ensure_json_serializable(response)
    
    return response

# Example usage:
if __name__ == "__main__":
    # Example of how to use the system
    query = "Show me the top 5 offenses by count"
    response = get_offenses_response_new(query)
    print(json.dumps(response, indent=2))