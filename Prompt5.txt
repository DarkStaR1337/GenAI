import re
import logging
import json
import os
from typing import Dict, Any, List, Tuple, Optional
from openai import AzureOpenAI

logger = logging.getLogger(__name__)

# Azure OpenAI Configuration
AZURE_OPENAI_ENDPOINT = os.getenv("AZURE_OPENAI_ENDPOINT", "YOUR_ENDPOINT_HERE")
AZURE_OPENAI_KEY = os.getenv("AZURE_OPENAI_KEY", "YOUR_KEY_HERE")
AZURE_OPENAI_DEPLOYMENT = os.getenv("AZURE_OPENAI_DEPLOYMENT", "gpt-4-turbo")

# Initialize Azure OpenAI Client
openai_client = AzureOpenAI(
    api_key=AZURE_OPENAI_KEY,
    api_version="2024-02-15-preview",
    azure_endpoint=AZURE_OPENAI_ENDPOINT
)


def translate_di_json_simple(di_json: Dict[str, Any]) -> Dict[str, Any]:
    """
    Simple translation of DI extracted JSON content.
    Translates key-value pairs and full content to English.
    
    Args:
        di_json: Document Intelligence result as dictionary
        
    Returns:
        Same DI JSON with translated content
    """
    try:
        # Extract text to translate
        text_to_translate = di_json.get('content', '')
        
        if not text_to_translate:
            logger.warning("No content found in DI JSON")
            return di_json
        
        logger.info(f"Translating DI content ({len(text_to_translate)} chars)...")
        
        # Call Azure OpenAI for translation
        response = openai_client.chat.completions.create(
            model=AZURE_OPENAI_DEPLOYMENT,
            messages=[
                {
                    "role": "system",
                    "content": "Translate the following text to English. Keep the same format and structure. Only translate the text content."
                },
                {
                    "role": "user",
                    "content": text_to_translate
                }
            ],
            max_tokens=4000,
            temperature=0
        )
        
        translated_content = response.choices[0].message.content.strip()
        
        # Add translated content to the JSON
        di_json['translated_content'] = translated_content
        
        logger.info(f"✓ Translation complete")
        
        return di_json
    
    except Exception as e:
        logger.error(f"Translation failed: {e}")
        return di_json


def extract_order_number_from_json(di_json: Dict[str, Any]) -> Optional[str]:
    """
    Extract order number from DI JSON (key-value pairs or translated content).
    
    Args:
        di_json: Document Intelligence result as dictionary
        
    Returns:
        Order number if found, None otherwise
    """
    
    # Order-related keywords (English)
    order_keywords = [
        'order', 'po', 'purchase order', 'order number', 'order no', 'po number',
        'po no', 'invoice', 'invoice number', 'invoice no', 'quotation', 'quote',
        'pedido', 'numero', 'factura', 'número'  # Spanish keywords too
    ]
    
    # First, try key-value pairs
    if 'key_value_pairs' in di_json:
        for kv in di_json['key_value_pairs']:
            if isinstance(kv, dict):
                key = kv.get('key', '').lower()
                value = kv.get('value', '')
                
                # Check if key matches order-related terms
                if any(keyword in key for keyword in order_keywords):
                    logger.info(f"Found order number in KV pair: {value}")
                    return value.strip()
    
    # If not found in KV pairs, search translated content
    if 'translated_content' in di_json:
        text = di_json['translated_content']
    else:
        text = di_json.get('content', '')
    
    if not text:
        return None
    
    # Search for order number patterns
    patterns = [
        r'Order\s*(?:Number|No\.?|Num)\s*[:\s]*([A-Za-z0-9\-\/]+)',
        r'PO\s*(?:Number|No\.?|#)?\s*[:\s]*([A-Za-z0-9\-\/]+)',
        r'Invoice\s*(?:Number|No\.?)\s*[:\s]*([A-Za-z0-9\-\/]+)',
        r'Quotation\s*(?:Number|No\.?)\s*[:\s]*([A-Za-z0-9\-\/]+)',
        r'Pedido\s*(?:Num\.?|Número)\s*[:\s]*([A-Za-z0-9\-\/]+)',
        r'Factura\s*(?:Num\.?|Número)\s*[:\s]*([A-Za-z0-9\-\/]+)',
    ]
    
    for pattern in patterns:
        match = re.search(pattern, text, re.IGNORECASE)
        if match:
            order_num = match.group(1).strip()
            logger.info(f"Found order number via regex: {order_num}")
            return order_num
    
    return None


def process_page_with_translation(page_bytes: bytes, 
                                  analyze_page_func,
                                  di_cache=None) -> Tuple[Dict[str, Any], Optional[str]]:
    """
    Analyze page with DI, translate if needed, extract order number.
    
    Args:
        page_bytes: Page bytes
        analyze_page_func: Function to call Document Intelligence
        di_cache: Optional cache instance
        
    Returns:
        Tuple of (di_json_dict, order_number)
    """
    
    # Get DI result
    di_result = analyze_page_func(page_bytes)
    
    if not di_result:
        return {}, None
    
    # Convert to dict format
    di_json = {
        'content': di_result.content if hasattr(di_result, 'content') else '',
        'key_value_pairs': [],
        'tables': []
    }
    
    # Extract key-value pairs
    if hasattr(di_result, 'key_value_pairs') and di_result.key_value_pairs:
        for kv in di_result.key_value_pairs:
            if kv.key and kv.value:
                di_json['key_value_pairs'].append({
                    'key': kv.key.content if kv.key.content else '',
                    'value': kv.value.content if kv.value.content else ''
                })
    
    # Extract tables
    if hasattr(di_result, 'tables') and di_result.tables:
        for table in di_result.tables:
            di_json['tables'].append({
                'row_count': table.row_count,
                'column_count': table.column_count
            })
    
    logger.info(f"DI extraction complete: {len(di_json['key_value_pairs'])} KV pairs, {len(di_json['tables'])} tables")
    
    # Translate the DI JSON
    di_json = translate_di_json_simple(di_json)
    
    # Extract order number from translated JSON
    order_number = extract_order_number_from_json(di_json)
    
    return di_json, order_number


def detect_boundaries_with_translated_orders(page_bytes_list: List[bytes],
                                             analyze_page_func,
                                             di_cache=None) -> List[int]:
    """
    Detect document boundaries based on order number changes (with translation).
    
    Args:
        page_bytes_list: List of page bytes
        analyze_page_func: Function to analyze page with DI
        di_cache: Optional cache
        
    Returns:
        List of boundary indices
    """
    
    boundaries = [0]
    last_order_number = None
    
    logger.info(f"\n{'='*70}")
    logger.info(f"BOUNDARY DETECTION WITH TRANSLATION")
    logger.info(f"Analyzing {len(page_bytes_list)} pages...")
    logger.info(f"{'='*70}\n")
    
    for i, page_bytes in enumerate(page_bytes_list):
        logger.info(f"Page {i + 1}/{len(page_bytes_list)}: Analyzing...")
        
        # Process with translation
        di_json, order_number = process_page_with_translation(
            page_bytes,
            analyze_page_func,
            di_cache
        )
        
        if order_number:
            logger.info(f"  ✓ Order number: {order_number}")
            
            if last_order_number is None:
                last_order_number = order_number
                logger.info(f"    First order number identified")
            elif order_number != last_order_number and i > 0:
                logger.info(
                    f"  ✓ NEW DOCUMENT - Order number changed\n"
                    f"    Previous: {last_order_number}\n"
                    f"    Current: {order_number}"
                )
                boundaries.append(i)
                last_order_number = order_number
            else:
                logger.info(f"    Same order number, continuing document")
        else:
            logger.info(f"  ⚠ Order number not found")
    
    logger.info(f"\n{'='*70}")
    logger.info(f"Detected {len(boundaries)} document(s)")
    logger.info(f"{'='*70}\n")
    
    return boundaries