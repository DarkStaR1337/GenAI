# Edge Case Analysis: PO Extraction System

## Edge Case 1: Cover Page Before PO (Orphaned Page Problem)

### Current Behavior
The system will **incorrectly treat the cover page as a separate document** because:
- The cover page lacks PO number, so it won't match the boundary detection logic
- It gets grouped as its own document (Document 1)
- The actual PO starts at Document 2

**Example Scenario:**
```
Input PDF:
  Page 1: Cover page (brochure, text-heavy, no PO number)
  Page 2: PO with "Page 1 of 3"
  Page 3: PO with "Page 2 of 3"
  Page 4: PO with "Page 3 of 3"

Current Output:
  Document 1: Page 1 only (cover - wrong!)
  Document 2: Pages 2-4 (actual PO)
```

### Root Cause
The boundary detection algorithm:
1. Always starts with `boundaries = [0]` (first page always starts a document)
2. Only adds new boundaries when it detects "Page 1" or PO number changes
3. Orphaned cover pages get assigned to their own group

### Recommended Solutions

#### Solution A: Orphaned Page Merging (Recommended)
**Merge orphaned pages (pages without PO/page numbers) with the next document:**

```python
def merge_orphaned_pages(groups: List[Dict[str, Any]], 
                         page_bytes_list: List[bytes],
                         use_di: bool = True) -> List[Dict[str, Any]]:
    """
    Merge pages without PO numbers/page numbers with the next document.
    Identifies 'orphaned' pages and attaches them to the following document.
    """
    merged_groups = []
    i = 0
    
    while i < len(groups):
        current_group = groups[i]
        
        # Check if current group is orphaned
        # (no PO number detected on any page)
        is_orphaned = True
        for page_bytes in current_group['pages']:
            po_num = None
            if use_di:
                di_result = di_cache.get(page_bytes)
                if di_result:
                    po_num = extract_po_number_from_di_result(di_result)
            if not po_num:
                po_num = extract_po_number_fallback(page_bytes)
            
            if po_num:
                is_orphaned = False
                break
        
        # If orphaned and not the last group, merge with next
        if is_orphaned and i + 1 < len(groups):
            logger.info(f"Detected orphaned group {i + 1} (pages {current_group['page_range']})")
            logger.info(f"  Merging with next group (pages {groups[i + 1]['page_range']})")
            
            next_group = groups[i + 1]
            merged_group = {
                'start_page': current_group['start_page'],
                'end_page': next_group['end_page'],
                'page_range': f"{current_group['start_page']}-{next_group['end_page']}",
                'pages': current_group['pages'] + next_group['pages']
            }
            merged_groups.append(merged_group)
            i += 2  # Skip both current and next
        else:
            merged_groups.append(current_group)
            i += 1
    
    return merged_groups
```

**Integration in main flow:**
```python
# In extract_pos_from_pdf(), after Step 3:
logger.info("\nSTEP 3.5: Merging orphaned pages...")
groups = merge_orphaned_pages(groups, page_bytes_list, use_di=use_di)
```

#### Solution B: Configurable Orphan Threshold
Allow merging of pages below a certain page count threshold:

```python
def merge_small_groups(groups: List[Dict[str, Any]], 
                      min_pages: int = 2) -> List[Dict[str, Any]]:
    """Merge groups with fewer than min_pages pages with the next group."""
    merged_groups = []
    i = 0
    
    while i < len(groups):
        current_group = groups[i]
        
        if len(current_group['pages']) < min_pages and i + 1 < len(groups):
            logger.info(f"Group {i + 1} has only {len(current_group['pages'])} page(s)")
            logger.info(f"  Merging with next group")
            
            next_group = groups[i + 1]
            merged_group = {
                'start_page': current_group['start_page'],
                'end_page': next_group['end_page'],
                'page_range': f"{current_group['start_page']}-{next_group['end_page']}",
                'pages': current_group['pages'] + next_group['pages']
            }
            merged_groups.append(merged_group)
            i += 2
        else:
            merged_groups.append(current_group)
            i += 1
    
    return merged_groups
```

---

## Edge Case 2: Missing PO Numbers AND Page Numbers

### Current Behavior
The system **cannot split the document** because:
- No "Page 1" detection → no boundary based on page numbering
- No PO number changes → no boundary based on PO identification
- `detect_document_boundaries()` returns only `[0]` (single document)

**Example Scenario:**
```
Input PDF:
  Page 1: PO without "Page 1" indicator, no PO number
  Page 2: Another PO without "Page 1" indicator, no PO number
  Page 3: Another PO without "Page 1" indicator, no PO number

Current Output:
  Document 1: Pages 1-3 (all merged as one)
```

### Root Cause
The boundary detection algorithm depends on:
1. Page numbers (e.g., "Page 1 of 3")
2. PO numbers (e.g., "PO-12345")

Without these, the system has **no mechanism to detect document boundaries**.

### Recommended Solutions

#### Solution A: Structural/Layout-Based Detection (Most Robust)
Detect new documents by analyzing page structure changes:

```python
def detect_layout_boundaries(page_bytes_list: List[bytes]) -> List[int]:
    """
    Detect document boundaries based on layout changes.
    Heuristics:
    1. Major whitespace/content positioning changes
    2. Significant text density changes
    3. Table presence changes
    4. Header/footer signature changes
    """
    boundaries = [0]
    
    previous_layout_hash = None
    
    for i, page_bytes in enumerate(page_bytes_list):
        try:
            doc = fitz.open(stream=page_bytes, filetype="pdf")
            page = doc[0]
            
            # Extract layout features
            text_blocks = page.get_text("blocks")
            images = page.get_images()
            
            # Calculate layout signature
            layout_hash = hashlib.md5(
                f"{len(text_blocks)}_{len(images)}_{page.get_text('text')[:100]}".encode()
            ).hexdigest()[:8]
            
            # If layout significantly changed, likely new document
            if previous_layout_hash and layout_hash != previous_layout_hash:
                # Additional check: verify it's not just a page break
                content_density = len(page.get_text("text").strip()) / (page.rect.width * page.rect.height)
                
                if content_density > 0.05:  # Significant content on new layout
                    logger.info(f"  Layout change detected at page {i + 1} - possible new document")
                    boundaries.append(i)
            
            previous_layout_hash = layout_hash
            doc.close()
            
        except Exception as e:
            logger.error(f"Layout analysis error on page {i + 1}: {e}")
    
    return boundaries
```

#### Solution B: Content Similarity Detection
Detect document boundaries by analyzing content blocks:

```python
def detect_content_boundaries(page_bytes_list: List[bytes]) -> List[int]:
    """
    Detect boundaries by analyzing content block similarity.
    If two consecutive pages have very different content blocks,
    likely a new document.
    """
    from difflib import SequenceMatcher
    
    boundaries = [0]
    previous_content_signature = None
    
    for i, page_bytes in enumerate(page_bytes_list):
        try:
            doc = fitz.open(stream=page_bytes, filetype="pdf")
            page = doc[0]
            
            # Get text blocks as signature
            text = page.get_text("text").strip()
            text_blocks = [block for block in page.get_text("blocks") if block[4]]
            
            # Create signature from first few blocks
            signature = " ".join([block[4][:50] for block in text_blocks[:5]])
            
            if previous_content_signature:
                # Compare similarity
                similarity = SequenceMatcher(
                    None, 
                    previous_content_signature[:300],
                    signature[:300]
                ).ratio()
                
                # If very different, might be new document
                if similarity < 0.3 and i > 0:
                    logger.info(f"  Content change detected at page {i + 1} (similarity: {similarity:.2f})")
                    boundaries.append(i)
            
            previous_content_signature = signature
            doc.close()
            
        except Exception as e:
            logger.error(f"Content analysis error on page {i + 1}: {e}")
    
    return boundaries
```

#### Solution C: Table Structure Detection (Recommended for POs)
Most POs have structured table layouts. Detect boundaries when table structure changes:

```python
def detect_table_boundary_changes(page_bytes_list: List[bytes]) -> List[int]:
    """
    Detect boundaries based on table structure/positions.
    Most POs have consistent table layouts; a change suggests new document.
    """
    boundaries = [0]
    previous_table_signature = None
    
    for i, page_bytes in enumerate(page_bytes_list):
        try:
            # Use DI to get table information
            di_result = analyze_page_with_di(page_bytes)
            
            if di_result and di_result.tables:
                # Create signature from tables
                table_signature = {
                    'count': len(di_result.tables),
                    'dimensions': [(t.row_count, t.column_count) for t in di_result.tables],
                    'content_preview': di_result.content[:200] if di_result.content else ""
                }
                
                if previous_table_signature:
                    # If table structure changed significantly
                    if (table_signature['count'] != previous_table_signature['count'] or
                        table_signature['dimensions'] != previous_table_signature['dimensions']):
                        
                        logger.info(
                            f"  Table structure change at page {i + 1}: "
                            f"from {previous_table_signature['count']} to {table_signature['count']} tables"
                        )
                        boundaries.append(i)
                
                previous_table_signature = table_signature
            elif previous_table_signature and i > 0:
                # Table disappeared - possible document boundary
                logger.info(f"  Tables disappeared at page {i + 1}")
                boundaries.append(i)
        
        except Exception as e:
            logger.error(f"Table analysis error on page {i + 1}: {e}")
    
    return boundaries
```

#### Solution D: Hybrid Approach (Best for Production)
Combine multiple detection methods with weighted scoring:

```python
def detect_boundaries_hybrid(page_bytes_list: List[bytes], 
                            use_di: bool = True) -> List[int]:
    """
    Hybrid boundary detection using multiple methods with confidence scoring.
    
    Detection Methods (in priority order):
    1. Page number = 1 (highest confidence)
    2. PO number change (high confidence)
    3. Table structure change (medium confidence)
    4. Layout changes (medium confidence)
    5. Content similarity (low confidence)
    """
    boundaries = [0]
    confidence_scores = {0: 1.0}  # Start has 100% confidence
    
    # Method 1 & 2: Existing detection (page numbers + PO numbers)
    existing_boundaries = detect_document_boundaries(page_bytes_list, use_di)
    for b in existing_boundaries[1:]:  # Skip 0
        confidence_scores[b] = confidence_scores.get(b, 0) + 0.5  # 50% confidence boost
    
    # Method 3: Table structure
    if use_di:
        table_boundaries = detect_table_boundary_changes(page_bytes_list)
        for b in table_boundaries[1:]:
            confidence_scores[b] = confidence_scores.get(b, 0) + 0.3  # 30% confidence boost
    
    # Method 4: Layout changes
    layout_boundaries = detect_layout_boundaries(page_bytes_list)
    for b in layout_boundaries[1:]:
        confidence_scores[b] = confidence_scores.get(b, 0) + 0.2  # 20% confidence boost
    
    # Filter: Keep boundaries with confidence > 0.4 (40%)
    final_boundaries = sorted([
        b for b, conf in confidence_scores.items() 
        if conf >= 0.4
    ])
    
    logger.info("\nBoundary Detection Confidence Scores:")
    for b in final_boundaries[1:]:  # Skip 0
        logger.info(f"  Page {b + 1}: {confidence_scores[b]:.1%} confidence")
    
    return final_boundaries
```

**Usage:**
```python
# In extract_pos_from_pdf(), replace Step 2:
logger.info("\nSTEP 2: Detecting document boundaries...")
# Try primary method first
boundaries = detect_document_boundaries(page_bytes_list, use_di=use_di)

# If only one document detected, try hybrid approach
if len(boundaries) == 1 and len(page_bytes_list) > 1:
    logger.info("No boundaries detected with primary method, trying hybrid approach...")
    boundaries = detect_boundaries_hybrid(page_bytes_list, use_di=use_di)
```

---

## Summary: Complete Implementation Strategy

### For Edge Case 1 (Cover Pages):
```python
# In extract_pos_from_pdf(), after grouping:
groups = group_pages_by_boundaries(page_bytes_list, boundaries)
groups = merge_orphaned_pages(groups, page_bytes_list, use_di=use_di)
```

### For Edge Case 2 (Missing Identifiers):
```python
# In extract_pos_from_pdf(), during boundary detection:
boundaries = detect_document_boundaries(page_bytes_list, use_di=use_di)

if len(boundaries) == 1 and len(page_bytes_list) > 1:
    logger.warning("No boundaries detected, attempting hybrid detection...")
    boundaries = detect_boundaries_hybrid(page_bytes_list, use_di=use_di)
```

### Configuration Options (Recommended):
```python
class POExtractionConfig:
    """Configuration for PO extraction behavior"""
    merge_orphaned_pages: bool = True
    orphan_page_threshold: int = 2  # Merge groups with < 2 pages
    
    use_hybrid_boundaries: bool = True  # Fall back to hybrid if needed
    confidence_threshold: float = 0.4  # Only keep boundaries above this
    
    boundary_detection_methods: List[str] = [
        "page_numbers",      # Page 1 detection
        "po_numbers",        # PO changes
        "table_structure",   # Table layout changes
        "layout_changes",    # Overall page layout
        "content_similarity" # Text content comparison
    ]
```

This approach handles both edge cases gracefully while maintaining backward compatibility with well-formed PDFs.