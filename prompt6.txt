import re
import logging
import json
from typing import Dict, Any, List, Tuple, Optional
from openai import AzureOpenAI
import hashlib

logger = logging.getLogger(__name__)

# Azure OpenAI Configuration
AZURE_OPENAI_ENDPOINT = os.getenv("AZURE_OPENAI_ENDPOINT", "YOUR_ENDPOINT_HERE")
AZURE_OPENAI_KEY = os.getenv("AZURE_OPENAI_KEY", "YOUR_KEY_HERE")
AZURE_OPENAI_DEPLOYMENT = os.getenv("AZURE_OPENAI_DEPLOYMENT", "gpt-4")  # or "gpt-35-turbo"

# Initialize Azure OpenAI Client
openai_client = AzureOpenAI(
    api_key=AZURE_OPENAI_KEY,
    api_version="2024-02-15-preview",
    azure_endpoint=AZURE_OPENAI_ENDPOINT
)


class TranslationCache:
    """Cache for translation results to avoid redundant API calls."""
    
    def __init__(self):
        self.cache = {}
    
    @staticmethod
    def generate_cache_key(text: str, target_lang: str = "en") -> str:
        """Generate cache key from text content."""
        content = f"{text}_{target_lang}"
        return hashlib.md5(content.encode()).hexdigest()
    
    def get(self, text: str, target_lang: str = "en") -> Optional[str]:
        """Get cached translation."""
        key = self.generate_cache_key(text, target_lang)
        return self.cache.get(key)
    
    def set(self, text: str, translated: str, target_lang: str = "en"):
        """Cache translation result."""
        key = self.generate_cache_key(text, target_lang)
        self.cache[key] = translated
    
    def clear(self):
        """Clear cache."""
        self.cache.clear()


# Global cache instance
translation_cache = TranslationCache()


class MultilingualOrderExtractor:
    """
    Extracts order identifiers (PO, Invoice numbers) from multilingual documents.
    Supports: English, Spanish, French, German, Portuguese, Italian, etc.
    """
    
    # Order number patterns in different languages
    ORDER_NUMBER_PATTERNS = {
        'en': [
            r'(?:ORDER|PO|PURCHASE ORDER|INVOICE|QUOTATION)\s*(?:NUMBER|NUM|NO\.?|ID)\s*[:\s]*([A-Za-z0-9\-\/]+)',
            r'(?:PO|PO\#|PONO)\s*[:\s]*([A-Za-z0-9\-\/]+)',
            r'(?:ORDER\s*ID)\s*[:\s]*([A-Za-z0-9\-\/]+)',
        ],
        'es': [
            r'(?:PEDIDO|NUMERO DE PEDIDO|NUM PEDIDO|N[ÚU]MERO DE ORDEN|ORDEN)\s*[:\s]*([A-Za-z0-9\-\/]+)',
            r'(?:FACTURA|NUMERO DE FACTURA|NUM\s*FACTURA)\s*[:\s]*([A-Za-z0-9\-\/]+)',
            r'(?:COTIZACI[ÓO]N|PRESUPUESTO)\s*[:\s]*([A-Za-z0-9\-\/]+)',
        ],
        'fr': [
            r'(?:COMMANDE|NUM[ÉE]RO DE COMMANDE|N°)\s*[:\s]*([A-Za-z0-9\-\/]+)',
            r'(?:FACTURE|NUM[ÉE]RO DE FACTURE)\s*[:\s]*([A-Za-z0-9\-\/]+)',
            r'(?:DEVIS|DEVIS NUM[ÉE]RO)\s*[:\s]*([A-Za-z0-9\-\/]+)',
        ],
        'de': [
            r'(?:BESTELLUNG|BESTELLNUMMER|BESTELLNR\.?)\s*[:\s]*([A-Za-z0-9\-\/]+)',
            r'(?:RECHNUNGSNUMMER|RECHNUNGS NR\.?)\s*[:\s]*([A-Za-z0-9\-\/]+)',
            r'(?:ANGEBOT|ANGEBOTSNUMMER)\s*[:\s]*([A-Za-z0-9\-\/]+)',
        ],
        'pt': [
            r'(?:PEDIDO|NUMERO DO PEDIDO|NÚM\s*PEDIDO)\s*[:\s]*([A-Za-z0-9\-\/]+)',
            r'(?:FATURA|NUMERO DA FATURA|NÚM\s*FATURA)\s*[:\s]*([A-Za-z0-9\-\/]+)',
            r'(?:COTAÇÃO|ORÇAMENTO|NÚMERO)\s*[:\s]*([A-Za-z0-9\-\/]+)',
        ],
        'it': [
            r'(?:ORDINE|NUMERO ORDINE|N°ORDINE)\s*[:\s]*([A-Za-z0-9\-\/]+)',
            r'(?:FATTURA|NUMERO FATTURA|N°FATTURA)\s*[:\s]*([A-Za-z0-9\-\/]+)',
            r'(?:PREVENTIVO|NUMERO PREVENTIVO)\s*[:\s]*([A-Za-z0-9\-\/]+)',
        ],
    }
    
    # Keywords to identify order-related fields
    ORDER_KEYWORDS = {
        'en': ['order', 'po', 'purchase', 'invoice', 'quotation', 'quote', 'number', 'num', 'no', 'id'],
        'es': ['pedido', 'factura', 'cotización', 'presupuesto', 'número', 'num', 'nro', 'orden'],
        'fr': ['commande', 'facture', 'devis', 'numéro', 'num', 'n°'],
        'de': ['bestellung', 'rechnung', 'angebot', 'nummer', 'nr', 'nro'],
        'pt': ['pedido', 'fatura', 'cotação', 'número', 'num', 'nro', 'orçamento'],
        'it': ['ordine', 'fattura', 'preventivo', 'numero', 'num', 'n°'],
    }
    
    def __init__(self):
        """Initialize the multilingual order extractor."""
        self.supported_languages = list(self.ORDER_NUMBER_PATTERNS.keys())
    
    def detect_language(self, text: str) -> str:
        """
        Detect the language of the text.
        
        Args:
            text: Text to detect language from
            
        Returns:
            Language code (e.g., 'es', 'en', 'fr')
        """
        try:
            # Use Azure OpenAI to detect language
            response = openai_client.chat.completions.create(
                model=AZURE_OPENAI_DEPLOYMENT,
                messages=[
                    {
                        "role": "system",
                        "content": "You are a language detection expert. Respond with ONLY the 2-letter ISO 639-1 language code (e.g., 'es', 'en', 'fr'). No explanation needed."
                    },
                    {
                        "role": "user",
                        "content": f"Detect the language of this text:\n\n{text[:500]}"
                    }
                ],
                max_tokens=10,
                temperature=0
            )
            
            lang_code = response.choices[0].message.content.strip().lower()
            logger.info(f"Detected language: {lang_code}")
            return lang_code
        
        except Exception as e:
            logger.error(f"Language detection failed: {e}")
            return 'en'  # Default to English
    
    def translate_text(self, text: str, source_lang: Optional[str] = None, 
                      target_lang: str = 'en') -> str:
        """
        Translate text using Azure OpenAI.
        
        Args:
            text: Text to translate
            source_lang: Source language code (auto-detected if None)
            target_lang: Target language code (default: 'en')
            
        Returns:
            Translated text
        """
        # If already in target language, return as-is
        if source_lang and source_lang == target_lang:
            logger.debug(f"Text already in {target_lang}, skipping translation")
            return text
        
        # Check cache
        cached = translation_cache.get(text, target_lang)
        if cached:
            logger.debug(f"Using cached translation for {target_lang}")
            return cached
        
        try:
            logger.info(f"Translating text to {target_lang}...")
            
            response = openai_client.chat.completions.create(
                model=AZURE_OPENAI_DEPLOYMENT,
                messages=[
                    {
                        "role": "system",
                        "content": f"You are a professional translator. Translate the following text to {target_lang}. Maintain formatting, line breaks, and special characters. Translate only the content, not labels or structure."
                    },
                    {
                        "role": "user",
                        "content": text
                    }
                ],
                max_tokens=4000,
                temperature=0  # Deterministic translation
            )
            
            translated = response.choices[0].message.content.strip()
            
            # Cache the translation
            translation_cache.set(text, translated, target_lang)
            
            logger.info(f"✓ Translation successful ({len(translated)} characters)")
            return translated
        
        except Exception as e:
            logger.error(f"Translation failed: {e}")
            return text  # Return original if translation fails
    
    def extract_order_number_native(self, text: str, language: str) -> Optional[str]:
        """
        Extract order number using native language patterns.
        
        Args:
            text: Text to search (already in native language)
            language: Language code
            
        Returns:
            Order number if found, None otherwise
        """
        if language not in self.ORDER_NUMBER_PATTERNS:
            logger.warning(f"Language {language} not supported, falling back to English patterns")
            language = 'en'
        
        patterns = self.ORDER_NUMBER_PATTERNS[language]
        text_upper = text.upper()
        
        for pattern in patterns:
            match = re.search(pattern, text_upper, re.IGNORECASE)
            if match:
                order_num = match.group(1).strip()
                logger.info(f"Found order number ({language}): {order_num}")
                return order_num
        
        return None
    
    def extract_from_di_result(self, di_result: Any, source_lang: Optional[str] = None) -> Dict[str, Any]:
        """
        Extract and translate order identifiers from DI result.
        
        Args:
            di_result: Document Intelligence result object
            source_lang: Source language (auto-detect if None)
            
        Returns:
            Dictionary with extracted order info and translations
        """
        result = {
            'source_language': source_lang,
            'detected_language': None,
            'original_text': '',
            'translated_text': '',
            'order_numbers': {
                'original': None,
                'original_language': None,
                'translated': None,
                'source': 'di_result'  # Can be 'di_result', 'kv_pairs', 'regex'
            },
            'all_kv_pairs': {},
            'translated_kv_pairs': {},
            'confidence_score': 0.0
        }
        
        if not di_result:
            logger.warning("Empty DI result provided")
            return result
        
        try:
            # Extract full content from DI
            full_text = ""
            if hasattr(di_result, 'content') and di_result.content:
                full_text = di_result.content
            
            result['original_text'] = full_text
            
            # Detect language if not provided
            detected_lang = source_lang
            if not detected_lang and full_text:
                detected_lang = self.detect_language(full_text[:500])
                result['detected_language'] = detected_lang
            
            # Try to extract order number from original text (native language)
            if full_text:
                order_num = self.extract_order_number_native(full_text, detected_lang or 'en')
                if order_num:
                    result['order_numbers']['original'] = order_num
                    result['order_numbers']['original_language'] = detected_lang
                    result['order_numbers']['source'] = 'native_regex'
                    result['confidence_score'] = 0.9
                    logger.info(f"✓ Found order number in original language: {order_num}")
            
            # Extract key-value pairs from DI
            if hasattr(di_result, 'key_value_pairs') and di_result.key_value_pairs:
                for kv in di_result.key_value_pairs:
                    if kv.key and kv.value:
                        key_text = kv.key.content if kv.key.content else ""
                        value_text = kv.value.content if kv.value.content else ""
                        
                        if key_text and value_text:
                            result['all_kv_pairs'][key_text] = value_text
            
            # Translate content and KV pairs to English
            if detected_lang and detected_lang != 'en' and full_text:
                logger.info(f"Document in {detected_lang}, translating to English...")
                
                translated_text = self.translate_text(full_text, detected_lang, 'en')
                result['translated_text'] = translated_text
                
                # Extract order number from translated text
                if not result['order_numbers']['original']:
                    order_num_translated = self.extract_order_number_native(
                        translated_text, 
                        'en'
                    )
                    if order_num_translated:
                        result['order_numbers']['translated'] = order_num_translated
                        result['order_numbers']['source'] = 'translated_regex'
                        result['confidence_score'] = 0.85
                        logger.info(f"✓ Found order number in translation: {order_num_translated}")
                
                # Translate KV pairs
                if result['all_kv_pairs']:
                    kv_text = "\n".join([f"{k}: {v}" for k, v in result['all_kv_pairs'].items()])
                    translated_kv = self.translate_text(kv_text, detected_lang, 'en')
                    
                    # Parse translated KV pairs
                    for line in translated_kv.split('\n'):
                        if ':' in line:
                            k, v = line.split(':', 1)
                            result['translated_kv_pairs'][k.strip()] = v.strip()
            else:
                result['translated_text'] = full_text
                result['translated_kv_pairs'] = result['all_kv_pairs']
            
            return result
        
        except Exception as e:
            logger.error(f"Error in extract_from_di_result: {e}")
            return result
    
    def identify_order_field_in_kv(self, kv_pairs: Dict[str, str]) -> Tuple[Optional[str], Optional[str]]:
        """
        Identify order number field from translated KV pairs.
        Matches common order number field names.
        
        Args:
            kv_pairs: Key-value pairs (should be in English)
            
        Returns:
            Tuple of (key, value) if found, (None, None) otherwise
        """
        order_keywords = self.ORDER_KEYWORDS['en']
        
        for key, value in kv_pairs.items():
            key_lower = key.lower()
            
            # Check how many keywords match this key
            keyword_matches = sum(1 for kw in order_keywords if kw in key_lower)
            
            if keyword_matches >= 1:
                logger.info(f"✓ Identified order field: '{key}' = '{value}'")
                return key, value
        
        return None, None


def extract_po_number_with_translation(page_bytes: bytes, 
                                       di_result: Any,
                                       source_language: Optional[str] = None) -> Tuple[Optional[str], str]:
    """
    Extract PO number with translation support.
    
    Args:
        page_bytes: Page bytes (for fallback regex)
        di_result: Document Intelligence result
        source_language: Source language hint (auto-detect if None)
        
    Returns:
        Tuple of (order_number, extraction_method)
        Methods: 'translated_kv', 'native_regex', 'translated_regex', 'fallback', None
    """
    extractor = MultilingualOrderExtractor()
    
    # Extract and translate
    extraction_data = extractor.extract_from_di_result(di_result, source_language)
    
    # Check for order number in various places
    if extraction_data['order_numbers']['original']:
        return (
            extraction_data['order_numbers']['original'],
            f"{extraction_data['order_numbers']['source']} ({extraction_data['detected_language']})"
        )
    
    if extraction_data['order_numbers']['translated']:
        return (
            extraction_data['order_numbers']['translated'],
            f"{extraction_data['order_numbers']['source']} (from translation)"
        )
    
    # Check translated KV pairs for order fields
    if extraction_data['translated_kv_pairs']:
        key, value = extractor.identify_order_field_in_kv(extraction_data['translated_kv_pairs'])
        if key and value:
            return value.strip(), f"translated_kv_pair ({key})"
    
    # Fallback to regex on original text
    order_num = extractor.extract_order_number_native(
        extraction_data['original_text'],
        extraction_data['detected_language'] or 'en'
    )
    if order_num:
        return order_num, f"native_regex ({extraction_data['detected_language']})"
    
    logger.warning("Could not extract order number even with translation")
    return None, "not_found"


def detect_boundaries_with_translation(page_bytes_list: List[bytes],
                                       di_cache=None) -> List[int]:
    """
    Detect document boundaries using translation-enhanced order number extraction.
    
    Combines structural detection with multilingual order number identification.
    
    Args:
        page_bytes_list: List of single-page PDF bytes
        di_cache: PageAnalysisCache instance
        
    Returns:
        List of page indices where new documents start
    """
    boundaries = [0]
    last_order_number = None
    last_language = None
    
    logger.info(f"\n{'='*80}")
    logger.info(f"BOUNDARY DETECTION WITH TRANSLATION SUPPORT")
    logger.info(f"Analyzing {len(page_bytes_list)} pages...")
    logger.info(f"{'='*80}\n")
    
    for i, page_bytes in enumerate(page_bytes_list):
        logger.info(f"Page {i + 1}/{len(page_bytes_list)}: Analyzing with translation...")
        
        # Get DI result
        di_result = None
        if di_cache:
            di_result = di_cache.get(page_bytes)
        
        if not di_result:
            logger.warning(f"  No DI result available for page {i + 1}")
            continue
        
        # Extract order number with translation
        order_num, extraction_method = extract_po_number_with_translation(
            page_bytes,
            di_result
        )
        
        if order_num:
            logger.info(f"  ✓ Order number found: {order_num}")
            logger.info(f"    Extraction method: {extraction_method}")
            
            # Check if order number changed
            if last_order_number is None:
                last_order_number = order_num
                logger.info(f"    First order number: {order_num}")
            elif order_num != last_order_number and i > 0:
                logger.info(
                    f"  ✓ NEW DOCUMENT - Order number changed\n"
                    f"    Previous: {last_order_number}\n"
                    f"    Current: {order_num}"
                )
                boundaries.append(i)
                last_order_number = order_num
            else:
                logger.info(f"    Same order number, continuing document")
        else:
            logger.info(f"  ⚠ Order number not found")
    
    logger.info(f"\n{'='*80}")
    logger.info(f"DETECTED {len(boundaries)} DOCUMENT(S):")
    for idx, boundary in enumerate(boundaries):
        end_idx = boundaries[idx + 1] - 1 if idx + 1 < len(boundaries) else len(page_bytes_list) - 1
        logger.info(f"  Document {idx + 1}: Pages {boundary + 1} to {end_idx + 1}")
    logger.info(f"{'='*80}\n")
    
    return boundaries


# Example integration with existing code:
def detect_boundaries_full_pipeline(page_bytes_list: List[bytes],
                                    use_di: bool = True,
                                    di_cache=None,
                                    structural_boundary_func=None) -> List[int]:
    """
    Full pipeline: Structural detection + Translation-based order extraction
    
    Priority:
    1. Structural detection (headers, footers, continuation)
    2. Translation-based order number detection
    3. Combine results
    
    Args:
        page_bytes_list: List of single-page PDF bytes
        use_di: Whether to use Document Intelligence
        di_cache: PageAnalysisCache instance
        structural_boundary_func: Structural detection function
        
    Returns:
        List of page indices where documents start
    """
    
    logger.info(f"\n{'#'*80}")
    logger.info(f"FULL PIPELINE: Structural + Translation-based Detection")
    logger.info(f"{'#'*80}\n")
    
    boundaries_set = {0}
    
    # Step 1: Structural detection
    if structural_boundary_func:
        logger.info("Step 1: Running structural boundary detection...")
        try:
            struct_boundaries = structural_boundary_func(page_bytes_list, di_cache)
            boundaries_set.update(struct_boundaries)
            logger.info(f"  ✓ Found {len(struct_boundaries) - 1} boundaries")
        except Exception as e:
            logger.warning(f"  Structural detection failed: {e}")
    
    # Step 2: Translation-based order detection
    logger.info("\nStep 2: Running translation-enhanced order number detection...")
    try:
        translation_boundaries = detect_boundaries_with_translation(
            page_bytes_list,
            di_cache
        )
        boundaries_set.update(translation_boundaries)
        logger.info(f"  ✓ Found {len(translation_boundaries) - 1} boundaries")
    except Exception as e:
        logger.warning(f"  Translation detection failed: {e}")
    
    final_boundaries = sorted(list(boundaries_set))
    
    logger.info(f"\n{'#'*80}")
    logger.info(f"FINAL RESULT: {len(final_boundaries)} document(s)")
    logger.info(f"{'#'*80}\n")
    
    return final_boundaries